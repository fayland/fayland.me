---
category: perl
layout: post
tags:
  - Parallel
  - fork
title: tips around Parallel::ForkManager
---
{% include JB/setup %}

<a href="http://search.cpan.org/perldoc?Parallel::ForkManager">Parallel::ForkManager</a> is my choice for 'forks'. it's simple to use, fit my demand and well-maintained.<br /><br />I use it frequently. for example, in scrape job with Tor. or there is a lot of db rows to process. forks is required to fast the whole progress when we have enough resource.<br /><br />here is some tips I use with Parallel::ForkManager.<br /><br />1. <a href="http://search.perl.org/perldoc?Scope::OnExit">Scope::OnExit</a><br />we know we always need call $pm-&gt;finish; in child so that we won't get something like 'Cannot start another process while you are in the child process'.<br />it won't be an issue if you have simple code without much next in a loop.<br />but it could be very troublesome if you have lots of 'next' in the loop. you have to call -&gt;finish before next. that's stupid. and Scope::OnExit can save you out.<br /><br /><blockquote>foreach my $part (@parts) {<br />&nbsp;&nbsp;&nbsp; $pm-&gt;start and next; # do the fork<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; ## when on next<br />&nbsp;&nbsp;&nbsp; on_scope_exit {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $pm-&gt;finish; # Terminates the child process<br />&nbsp;&nbsp;&nbsp; };<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; # do whatever you like, call 'next' on whenever you want.<br />}<br /></blockquote> 2. <a href="http://search.perl.org/perldoc?List::MoreUtils">List::MoreUtils</a><br />see you have a big list to process, simple you can fork on every element. but in this case, you'll need init or clone every object in forked child, and it's expensive sometimes.so how about something like this, you divide the big list into $PROCESS parts, then fork on each part. so at last, you just init/clone $PROCESS times instead of scalar(@big_list) times. List::MoreUtils part can do the job here:<br /><br /><blockquote>my @big_list = (1 .. 10000); # from file, database or whatever<br />my $i = 0;<br />my @parts = part { $i++ % $FORK_CHILDREN } @big_list;<br />foreach my $part (@parts) {<br />&nbsp;&nbsp;&nbsp; $pm-&gt;start and next; # do the fork<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; ## when on next<br />&nbsp;&nbsp;&nbsp; on_scope_exit {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $pm-&gt;finish; # Terminates the child process<br />&nbsp;&nbsp;&nbsp; };<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; # init dbh/ua etc.<br /><br />&nbsp;&nbsp;&nbsp; while (my $ele = shift @$part) {<br /><br />&nbsp;&nbsp;&nbsp; }<br />}<br /></blockquote>3. DBI and LWP::UserAgent clone<br />I don't know if it's wise or not to call DBI-&gt;connect or LWP::UserAgent-&gt;new in child code. but usually we can do<br /><br /><blockquote>my $dbh = $odbh-&gt;clone();<br />my $ua2 = $ua-&gt;clone(); # will copy the cookies and referer etc.<br /></blockquote>4. share variables between parent and children<br />well, I don't like threads::shared. and I don't like IPC.<br />usually a cache solution can do the tricky. from one simple txt file (with lock), maybe you can use <a href="http://search.perl.org/perldoc?Parallel::Scoreboard">Parallel::Scoreboard</a> to my choice <a href="http://search.perl.org/perldoc?Cache::FastMmap">Cache::FastMmap</a><br />sample code below:<br /><br /><blockquote>my $cache = Cache::FastMmap-&gt;new;<br />my @array = (1 .. 10); # in parent<br />$cache-&gt;set($cache_key, \@array);<br /><br />### then in forked child after -&gt;start<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $cache-&gt;get_and_set( $cache_key, sub {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $v = $_[1];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push @$v, $value_in_child;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return $v;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } );<br /><br />### after $pm-&gt;wait_all_children;<br />my $array_ref = $cache-&gt;get($cache_key);<br /><br /></blockquote>get_and_set does the tricky here. anyway, that's just my solution. it won't fit into every situation.<br /><br />that's all for Parallel::ForkManager. hope it helps when you want to use it.<br /><br />Thanks.<br />